import numpy as np

"""
    The VELO_PARAMS is different from the original KIITI [R|t].
    The original [R|t] is the H from LiDAR to camera 0 (grey,left), however, we need the H from LiDAR to camera 2 (rgb, left).
    The official projection equation is y=P@R@H@x, where P is a 3*4 matrix. 
    According to the KITTI paper, P[:3,:3] is exactly the intrinsic matrix. P[:3, 3] represents the baseline from camera 0 to 2.
    We transform the projection equation as y=P[:3, 3]@
"""



def get_calib(date):
    if date == '2011_09_26':
        return CAM02_PARAMS_2011_09_26, VELO_PARAMS_2011_09_26
    elif date == '2011_09_30':
        return CAM02_PARAMS_2011_09_30, VELO_PARAMS_2011_09_30

CAM02_PARAMS_2011_09_26 = dict(
    fx = 7.215377e+02,
    fy = 7.215377e+02,
    cx = 6.095593e+02,
    cy = 1.728540e+02,
    rot = [[9.999758e-01, -5.267463e-03, -4.552439e-03],
           [5.251945e-03, 9.999804e-01, -3.413835e-03],
           [4.570332e-03, 3.389843e-03, 9.999838e-01]],
    trans = [[5.956621e-02], [2.900141e-04], [2.577209e-03]],
)

VELO_PARAMS_2011_09_26 = dict(
    #rot = [[7.533745e-03, -9.999714e-01, -6.166020e-04],   gyf
    #       [1.480249e-02, 7.280733e-04, -9.998902e-01],
    #       [9.998621e-01, 7.523790e-03, 1.480755e-02]],
    #trans = [[-4.069766e-03], [-7.631618e-02], [-2.717806e-01]],
    # multiply the R0
    rot = [[2.34773698e-04, -9.99944155e-01, -1.05634778e-02],
           [1.04494074e-02, 1.05653536e-02, -9.99889574e-01],
           [9.99945389e-01, 1.24365378e-04,  1.04513030e-02]],
    trans = [[5.93721868e-02], [-7.48089053e-02], [-2.69386912e-01]],
)

CAM02_PARAMS_2011_09_30 = dict(
    fx = 7.070912e+02,
    fy = 7.070912e+02,
    cx = 6.018873e+02,
    cy =1.831104e+02,
    rot = [[9.999805e-01, -4.971067e-03, -3.793081e-03],
           [4.954076e-03, 9.999777e-01, -4.475856e-03],
           [3.815246e-03, 4.456977e-03, 9.999828e-01]],
    trans = [[6.030222e-02], [-1.293125e-03], [5.900421e-03]],
)

VELO_PARAMS_2011_09_30 = dict(
    #rot = [[7.027555e-03, -9.999753e-01, 2.599616e-05],
    #       [-2.254837e-03, -4.184312e-05, -9.999975e-01],
    #       [9.999728e-01, 7.027479e-03, -2.255075e-03]],
    #trans = [[-7.137748e-03], [-7.482656e-02], [-3.336324e-01]],

    rot = [[-0.00185774, -0.99996595, -0.00803998],
           [-0.00648147, 0.00805186, -0.99994661],
           [0.99997731, -0.00180553, -0.0064962]],
    trans = [[0.06152684], [-0.07320761], [-0.32779358]],
)

if __name__ == '__main__':
    import numpy as np
    rot = np.array([[7.533745e-03, -9.999714e-01, -6.166020e-04],
          [1.480249e-02, 7.280733e-04, -9.998902e-01],
          [9.998621e-01, 7.523790e-03, 1.480755e-02]])
    rot2 = np.array([[9.999758e-01, -5.267463e-03, -4.552439e-03],
           [5.251945e-03, 9.999804e-01, -3.413835e-03],
           [4.570332e-03, 3.389843e-03, 9.999838e-01]])
    rot0 = np.array('9.999239e-01 9.837760e-03 -7.445048e-03 -9.869795e-03 9.999421e-01 -4.278459e-03 '
                    '7.402527e-03 4.351614e-03 9.999631e-01'.split(' ')).astype(np.float64).reshape(3,3)
    P2 = np.array([4.485728e+01, 2.163791e-01, 2.745884e-03]).reshape(3, 1)
    P2[0] = (P2[0]-P2[2]*6.018873e+02)/7.070912e+02
    P2[1] = (P2[1]-P2[2]*1.831104e+02)/7.215377e+02
    trans = np.array([[-4.069766e-03], [-7.631618e-02], [-2.717806e-01]]).reshape(3,1)
    print(rot0@trans+P2)
